package processors

import (
	"errors"
	"fmt"
	"go/parser"
	"go/token"
	"path/filepath"
	"strings"

	"github.com/golangci/golangci-lint/pkg/logutils"
	"github.com/golangci/golangci-lint/pkg/result"
)

const (
	genCodeGenerated = "code generated"
	genDoNotEdit     = "do not edit"
	genAutoFile      = "autogenerated file" // easyjson
)

var _ Processor = &AutogeneratedExclude{}

type ageFileSummary struct {
	isGenerated bool
}

type AutogeneratedExclude struct {
	debugf logutils.DebugFunc

	fileSummaryCache map[string]*ageFileSummary
}

func NewAutogeneratedExclude() *AutogeneratedExclude {
	return &AutogeneratedExclude{
		debugf:           logutils.Debug(logutils.DebugKeyAutogenExclude),
		fileSummaryCache: map[string]*ageFileSummary{},
	}
}

func (p *AutogeneratedExclude) Name() string {
	return "autogenerated_exclude"
}

func (p *AutogeneratedExclude) Process(issues []result.Issue) ([]result.Issue, error) {
	return filterIssuesErr(issues, p.shouldPassIssue)
}

func (p *AutogeneratedExclude) Finish() {}

func (p *AutogeneratedExclude) shouldPassIssue(issue *result.Issue) (bool, error) {
	if issue.FromLinter == "typecheck" {
		// don't hide typechecking errors in generated files: users expect to see why the project isn't compiling
		return true, nil
	}

	if filepath.Base(issue.FilePath()) == "go.mod" {
		return true, nil
	}

	if !isGoFile(issue.FilePath()) {
		return false, nil
	}

	fs := p.fileSummaryCache[issue.FilePath()]
	if fs != nil {
		return !fs.isGenerated, nil
	}

	fs = &ageFileSummary{}
	p.fileSummaryCache[issue.FilePath()] = fs

	if issue.FilePath() == "" {
		return false, errors.New("no file path for issue")
	}

	doc, err := getDoc(issue.FilePath())
	if err != nil {
		return false, fmt.Errorf("failed to get doc of file %s: %w", issue.FilePath(), err)
	}

	fs.isGenerated = p.isGeneratedFileLax(doc)

	p.debugf("file %q is generated: %t", issue.FilePath(), fs.isGenerated)

	// don't report issues for autogenerated files
	return !fs.isGenerated, nil
}

// isGeneratedFileLax reports whether the source file is generated code.
// Using a bit laxer rules than https://go.dev/s/generatedcode to match more generated code.
// See https://github.com/golangci/golangci-lint/issues/48 and https://github.com/golangci/golangci-lint/issues/72.
func (p *AutogeneratedExclude) isGeneratedFileLax(doc string) bool {
	markers := []string{genCodeGenerated, genDoNotEdit, genAutoFile}

	doc = strings.ToLower(doc)

	for _, marker := range markers {
		if strings.Contains(doc, marker) {
			p.debugf("doc contains marker %q: file is generated", marker)

			return true
		}
	}

	p.debugf("doc of len %d doesn't contain any of markers: %s", len(doc), markers)

	return false
}

func getDoc(filePath string) (string, error) {
	fset := token.NewFileSet()
	syntax, err := parser.ParseFile(fset, filePath, nil, parser.PackageClauseOnly|parser.ParseComments)
	if err != nil {
		return "", fmt.Errorf("failed to parse file: %w", err)
	}

	var docLines []string
	for _, c := range syntax.Comments {
		docLines = append(docLines, strings.TrimSpace(c.Text()))
	}

	return strings.Join(docLines, "\n"), nil
}

func isGoFile(name string) bool {
	return filepath.Ext(name) == ".go"
}
